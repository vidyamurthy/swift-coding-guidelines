<p><strong>Swift Best Practices</strong></p>

<p><strong>Naming</strong></p>

<p>As per the Swift Programming Language, type names should be upper camel case (example: “<code>VideoPlayerViewController</code>”).</p>

<p>Variables and constants should be lower camel case (example “<code>videoPlayer</code>”).</p>

<p>Do not use any form of Hungarian notation (e.g. k for constants, m for methods), instead use short concise names and use Xcode’s type Quick Help (⌥ + click) to discover a variable’s type. Similarly do not use <code>SNAKE_CASE</code>.</p>

<p>It also applies to enum values, which should be lowercase (as defined by “0006-apply-api-guidelines-to-the-standard-library”):</p>

<pre><code>enum Planet {
        case mercury, venus, earth, mars, jupiter, saturn, uranus, neptune
      }
</code></pre>

<p><strong>Types</strong></p>

<p>Always use Swift’s native types when available. Swift offers bridging to Objective-C so you can still use the full set of methods as needed.</p>

<p><em>Preferred:</em></p>

<pre><code>let width = 120.0                                    // Double
let widthString = (width as NSNumber).stringValue    // String
</code></pre>

<p><em>Not Preferred:</em></p>

<pre><code>let width: NSNumber = 120.0                          // NSNumber
let widthString: NSString = width.stringValue        // NSString
</code></pre>

<p>In Sprite Kit code, use <code>CGFloat</code> if it makes the code more succinct by avoiding too many conversions.</p>

<p><strong>Constants</strong></p>

<p>Constants are defined using the <code>let</code> keyword, and variables with the <code>var</code> keyword. Always use <code>let</code> instead of <code>var</code> if the value of the variable will not change.</p>

<p>Tip: A good technique is to define everything using <code>let</code> and only change it to <code>var</code> if the compiler complains!</p>

<p>You can define constants on a type rather than on an instance of that type using type properties. To declare a type property as a constant simply use static let. Type properties declared in this way are generally preferred over global constants because they are easier to distinguish from instance properties. Example:</p>

<p><em>Preferred:</em></p>

<pre><code>enum Math {
  static let e = 2.718281828459045235360287
  static let root2 = 1.41421356237309504880168872
}

let hypotenuse = side * Math.root2
</code></pre>

<p>Note: The advantage of using a case-less enumeration is that it can’t accidentally be instantiated and works as a pure namespace.</p>

<p><em>Not Preferred:</em></p>

<pre><code>let e = 2.718281828459045235360287  // pollutes global namespace
let root2 = 1.41421356237309504880168872

let hypotenuse = side * root2 // what is root2?
</code></pre>

<p><strong>Static Methods and Variable Type Properties</strong></p>

<p>Static methods and type properties work similarly to global functions and global variables and should be used sparingly. They are useful when functionality is scoped to a particular type or when Objective-C interoperability is required.</p>

<p><strong>Optionals</strong></p>

<p>Declare variables and function return types as optional with <code>?</code> where a <code>nil</code> value is acceptable.</p>

<p>Use implicitly unwrapped types declared with <code>!</code> only for instance variables that you know will be initialized later before use, such as subviews that will be set up in <code>viewDidLoad</code>.</p>

<p>When accessing an optional value, use optional chaining if the value is only accessed once or if there are many optionals in the chain:</p>

<pre><code>self.textContainer?.textLabel?.setNeedsDisplay()
</code></pre>

<p>Use optional binding when it’s more convenient to unwrap once and perform multiple operations:</p>

<pre><code>if let textContainer = self.textContainer {
  // do many things with textContainer
}
</code></pre>

<p>When naming optional variables and properties, avoid naming them like <code>optionalString</code> or <code>maybeView</code> since their optional-ness is already in the type declaration.</p>

<p>For optional binding, shadow the original name when appropriate rather than using names like <code>unwrappedView</code> or <code>actualLabel</code>.</p>

<p><em>Preferred:</em></p>

<pre><code>var subview: UIView?
var volume: Double?

// later on...
if let subview = subview, let volume = volume {
  // do something with unwrapped subview and volume
}
</code></pre>

<p><em>Not Preferred:</em></p>

<pre><code>var optionalSubview: UIView?
var volume: Double?
if let unwrappedSubview = optionalSubview {
  if let realVolume = volume {
    // do something with unwrappedSubview and realVolume
  }
}
</code></pre>

<p><strong>Lazy Initialization</strong></p>

<p>Consider using lazy initialization for finer grain control over object lifetime. This is especially true for <code>UIViewController</code> that loads views lazily. You can either use a closure that is immediately called { }() or call a private factory method. Example:</p>

<pre><code>lazy var locationManager: CLLocationManager = self.makeLocationManager()

private func makeLocationManager() -&gt; CLLocationManager {
  let manager = CLLocationManager()
  manager.desiredAccuracy = kCLLocationAccuracyBest
  manager.delegate = self
  manager.requestAlwaysAuthorization()
  return manager
}
</code></pre>

<p>Notes: <br>
•   <code>[unowned self]</code> is not required here. A retain cycle is not created. <br>
•   Location manager has a side-effect for popping up UI to ask the user for permission so fine grain control makes sense here.</p>

<p><strong>Type Inference</strong></p>

<p>Prefer compact code and let the compiler infer the type for constants or variables of single instances. Type inference is also appropriate for small (non-empty) arrays and dictionaries. When required, specify the specific type such as <code>CGFloat</code> or <code>Int16</code>.</p>

<p><em>Preferred:</em></p>

<pre><code>let message = "Click the button"
let currentBounds = computeViewBounds()
var names = ["Mic", "Sam", "Christine"]
let maximumWidth: CGFloat = 106.5
</code></pre>

<p><em>Not Preferred:</em></p>

<pre><code>let message: String = "Click the button"
let currentBounds: CGRect = computeViewBounds()
let names = [String]()
</code></pre>

<p><strong>Type Annotation for Empty Arrays and Dictionaries</strong></p>

<p>For empty arrays and dictionaries, use <code>type</code> annotation. (For an array or dictionary assigned to a large, multi-line literal, use type annotation.)</p>

<p><em>Preferred:</em></p>

<pre><code>var names: [String] = []
var lookup: [String: Int] = [:]
</code></pre>

<p><em>Not Preferred:</em></p>

<pre><code>var names = [String]()
var lookup = [String: Int]()
</code></pre>

<p>NOTE: Following this means picking descriptive names is even more important than before.</p>

<p><strong>Syntactic Sugar</strong></p>

<p>Prefer the shortcut versions of type declarations over the full generics syntax.</p>

<p><em>Preferred:</em></p>

<pre><code>var deviceModels: [String]
var employees: [Int: String]
var faxNumber: Int?
</code></pre>

<p><em>Not Preferred:</em></p>

<pre><code>var deviceModels: Array&lt;String&gt;
var employees: Dictionary&lt;Int, String&gt;
var faxNumber: Optional&lt;Int&gt;
</code></pre>

<p><strong>Control Flow</strong></p>

<p>Prefer the for-in style of for loop</p>

<p><em>Preferred:</em></p>

<pre><code>for _ in 0..&lt;3 {
  print("Hello three times")
}

for (index, person) in attendeeList.enumerated() {
  print("\(person) is at position #\(index)")
}

for index in stride(from: 0, to: items.count, by: 2) {
  print(index)
}

for index in (0...3).reversed() {
  print(index)
}
</code></pre>

<p><strong>Singletons</strong></p>

<p>Singletons are simple in Swift:</p>

<pre><code>class ControversyManager {
    static let shared = ControversyManager()
}
</code></pre>

<p>The Swift runtime will make sure that the singleton is created and accessed in a thread-safe manner.</p>

<p>Singletons should generally just be accessed via “<code>shared</code>” static property unless you have a compelling reason to name it otherwise. Do not use static functions or global functions to access your singleton. <br>
(Because singletons are so easy in Swift and because consistent naming saves you so much time you will have even more time to complain about how singletons are an anti-pattern and should be avoided at all costs. Your fellow developers will thank you.)</p>

<p><strong>Protocol Conformance</strong></p>

<p>When adding protocol conformance to a model, prefer adding a separate extension for the protocol methods. This keeps the related methods grouped together with the protocol and can simplify instructions to add a protocol to a class with its associated methods.</p>

<p><em>Preferred:</em></p>

<pre><code>class MyViewController: UIViewController {
  // class stuff here
}

// MARK: - UITableViewDataSource
extension MyViewController: UITableViewDataSource {
  // table view data source methods
}

// MARK: - UIScrollViewDelegate
extension MyViewController: UIScrollViewDelegate {
  // scroll view delegate methods
}
</code></pre>

<p><em>Not Preferred:</em></p>

<pre><code>class MyViewController: UIViewController, UITableViewDataSource, UIScrollViewDelegate {
  // all methods
}
</code></pre>

<p>For UIKit view controllers, consider grouping lifecycle, custom accessors, and IBAction in separate class extensions.</p>

<p><em>Preferred:</em></p>

<pre><code>class MyViewController: UIViewController {
    ...
}
// MARK: - Animation Methods
extension MyViewController {
    func animateSaveButton() {
        ...
    }
    func fanimateCustomActivityIndicator() {
        ...
    }
}
// MARK: - Validation Methods
extension MyViewController {
    func validatePersonalInfo() -&gt; Bool {
        ...
    }
    func validatePaymentInfo() -&gt; Bool {
        ...
    }
}
</code></pre>

<p>If an extension contains a lot of code, consider separating that extension into a separate <code>.swift</code> file.</p>

<p><strong>Minimal Imports</strong></p>

<p>Keep imports minimal. For example, don’t import <code>UIKit</code> when importing <code>Foundation</code> will suffice.</p>

<p><strong>Early Returns &amp; Guards</strong></p>

<p>When possible, use <code>guard</code> statements to handle early returns or other exits (e.g. fatal errors or thrown errors).</p>

<p><em>Prefer:</em></p>

<pre><code>guard let safeValue = criticalValue else {
    fatalError("criticalValue cannot be nil here")
}
someNecessaryOperation(safeValue)
</code></pre>

<p><em>to:</em></p>

<pre><code>if let safeValue = criticalValue {
    someNecessaryOperation(safeValue)
} else {
    fatalError("criticalValue cannot be nil here")
}
</code></pre>

<p><em>or:</em></p>

<pre><code>if criticalValue == nil {
    fatalError("criticalValue cannot be nil here")
}
someNecessaryOperation(criticalValue!)
</code></pre>

<p>This flattens code otherwise tucked into an <code>if let</code> block, and keeps early exits near their relevant condition instead of down in an <code>else</code> block.</p>

<p><strong>Use of Self</strong></p>

<p>For conciseness, avoid using <code>self</code> since Swift does not require it to access an object’s properties or invoke its methods.</p>

<p>Use <code>self</code> only when required by the compiler (in <code>@escaping</code> closures, or in initializers to disambiguate properties from arguments). In other words, if it compiles without <code>self</code> then omit it.</p>

<p><strong>Closures</strong></p>

<p>Try using closures as and when possible. Closure expressions are a way to write inline closures in a brief, focused syntax. Closure expressions provide several syntax optimizations for writing closures in a shortened form without loss of clarity or intent.</p>

<p>Closure expression syntax has the following general form:</p>

<pre><code>{ (parameters) -&gt; return type in
    statements
}
</code></pre>

<p>Example:</p>

<pre><code>reversedNames = names.sorted(by: { (s1: String, s2: String) -&gt; Bool in
return s1 &gt; s2
   })
</code></pre>

<p>Inferring Type From Context:</p>

<pre><code>reversedNames = names.sorted(by: { s1, s2 in return s1 &gt; s2 } )
</code></pre>

<p>Implicit Returns from Single-Expression Closures</p>

<pre><code>reversedNames = names.sorted(by: { s1, s2 in s1 &gt; s2 } )
</code></pre>

<p>Shorthand Argument Names</p>

<pre><code>reversedNames = names.sorted(by: { $0 &gt; $1 } )
</code></pre>

<p>Here, <code>$0</code> and <code>$1</code> refer to the closure’s first and second String arguments. <br>
For a detailed explanation, please refer:   <a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Closures.html">https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Closures.html</a></p>

<p><strong>CoreData</strong></p>

<p>All fetch requests should be constructed as:</p>

<pre><code>let fetchRequest : NSFetchRequest&lt;Item&gt; = Item.fetchRequest()
</code></pre>

<p>The array that holds the result value should be of type <code>[Item]</code> and not <code>NSArray</code> <br>
<code>NSFetchRequest</code> is now generic. <code>NSFetchedResultsController</code> is generic too. Therefore, when declaring variables, you have to use a generic declaration, e.g.:</p>

<pre><code>var fetchedResultsController: NSFetchedResultsController&lt;Item&gt;?
</code></pre>

<p><strong>References</strong> <br>
<a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/TheBasics.html#//apple_ref/doc/uid/TP40014097-CH5-ID309">https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/TheBasics.html#//apple_ref/doc/uid/TP40014097-CH5-ID309</a> <br>
<a href="https://github.com/raywenderlich/swift-style-guide">https://github.com/raywenderlich/swift-style-guide</a> <br>
<a href="https://github.com/schwa/Swift-Community-Best-Practices">https://github.com/schwa/Swift-Community-Best-Practices</a> <br>
<a href="https://www.toptal.com/swift/tips-and-practices">https://www.toptal.com/swift/tips-and-practices</a></p>